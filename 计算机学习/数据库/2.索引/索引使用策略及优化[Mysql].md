# 索引使用策略及优化[Mysql]
#数据库  #索引 #io
MySQL的优化主要分为**结构优化（Scheme optimization）**和**查询优化（Query optimization）**。
本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于索引的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。

## 1 联合索引及最左前缀原理
### 联合索引（复合索引）

首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：

-   第一个字段一定是有序的
-   当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的
    
    | A | B | C |
	| ---- | ---- | ---- |
    | 1 | 2 | 3 |   
    | 1 | 4 | 2 |   
    | 1 | 1 | 4 |   
    | 2 | 3 | 5 |   
    | 2 | 4 | 4 |   
    | 2 | 4 | 6 |   
    | 2 | 5 | 5 |
    

其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。
### 最左前缀原理

我们再来详细介绍一下联合索引的查询。还是上面例子，我们在`（a,b,c）`字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以：

以下的查询方式都可以用到索引

```
select * from table where a=1；
select * from table where a=1 and b=2；
select * from table where a=1 and b=2 and c=3；
```

上面三个查询按照 `（a ）, （a，b ）,（a，b，c ）`的顺序都可以利用到索引，这就是最左前缀匹配。

如果查询语句是：

```
select * from table where a=1 and c=3；
```
 那么只会用到索引a。

如果查询语句是：

```
select * from table where b=2 and c=3；
```

 因为没有用到最左前缀a，所以这个查询是没有用到索引的。

如果用到了最左前缀，但是顺序颠倒会用到索引码？
比如：

```
select * from table where b=2 and a=1；
select * from table where b=2 and a=1 and c=3；
```

如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。

### 前缀索引

除了联合索引之外，对mysql来说其实还有一种前缀索引。前缀索引就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

一般来说以下情况可以使用前缀索引：
-   字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’
-   字符串本身可能比较长，而且前几个字符就开始不相同。
> - 比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短。
> - 另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。
> - 相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。
-   前一半字符的索引选择性就已经接近于全字段的索引选择性。
>   如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。

一些文章中也提到：
MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：**MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。**

## 2 索引优化策略

1.  最左前缀匹配原则，上面讲到了
2.   对 where,on,group by,order by 中出现的列使用索引
3.   尽量选择区分度高的列作为索引,**区分度的公式是count(distinct col)/count(*)**，表示字段不重复的比例，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度≈0
4.  对较小的数据列使用索引,这样会使索引文件更小,同时内存页中也可以装载更多的索引键
5.   索引列不能参与计算，保持列“干净”。
	比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
6.   为较长的字符串使用前缀索引
7.  不要过多创建索引, 权衡索引个数与DML（插入、删除)之间关系。
		建立的索引过多，会影响插入、删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建	
8.   主键外键一定要建索引 (innoDB主键有集簇索引)

其他经验
-   尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
-   对于like查询，”%”不放在前面。 可以走索引  
    `SELECT * FROM`houdunwang`WHERE`uname`LIKE'后盾%' -- 走索引`   
    `SELECT * FROM`houdunwang`WHERE`uname`LIKE "%后盾%" -- 不走索引`
	
-   查询where条件数据类型不匹配(类型转换)也无法使用索引   
    字符串与数字比较不使用索引;   
    `CREATE TABLE`a`(`a`char(10));`   
    `EXPLAIN SELECT * FROM`a`WHERE`a`="1"` – 走索引   
    EXPLAIN SELECT * FROM `a` WHERE `a`=1 – 不走索引   
    正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因