#JAVA_内存模型 #JMM

不是 [[JVM内存结构模型]]

Java内存模型的英文名称为Java Memory Model(JMM)，其并不想JVM内存结构一样真实存在，而是一个抽象的概念。通过JSR-133 Java Memory Model and Thread Specification中的描述，我们知道JMM和线程有关，它描述了一组规范或规则，一个线程对共享变量的写入时对另一个线程是可见的。  
Java多线程对共享内存进行操作的时候，会存在一些如可见性、原子性和顺序性的问题，JMM是围绕着多线程通信及相关的一些特性而建立的模型。而JMM定义了一些语法集，而这些语法集映射到Java语言的volatile、synchronized等关键字

## 原因
内存的读写速度远远赶不上cpu =》 因此cpu厂商在每颗cpu上加上高速缓存(贵，小) =》多核cpu中，每个处理器都有各自的高速缓存(L1,L2,L3)，而主内存只有一个 =》
```
如何保证多个处理器运算涉及到同一个内存区域时，多线程场景下会存在缓存一致性问题，那么运行时保证数据一致性？

为了解决这个问题，各个处理器需遵循一些协议保证一致性。【如MSI，MESI啥啥的协议。。】
```
### Memory Barrier
CPU中，每个CPU又有多级缓存【上图统一定义为高速缓存】，一般分为L1,L2,L3，因为这些缓存的出现，提高了数据访问性能，避免每次都向内存索取，但是弊端也很明显，不能实时的和内存发生信息交换，分**在不同CPU执行的不同线程对同一个变量的缓存值不同。

 硬件层的内存屏障分为两种：`Load Barrier` 和 `Store Barrier`即读屏障和写屏障。【内存屏障是硬件层的】
强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。


详解：
see: https://www.jianshu.com/p/bf158fbb2432
