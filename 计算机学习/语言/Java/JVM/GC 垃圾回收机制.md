-
# GC 垃圾回收机制
#面试 #JVM #垃圾回收

原文 [# 深入理解JVM-内存模型（jmm）和GC](https://www.jianshu.com/p/76959115d486)

相关： [[JVM内存结构模型]]

## 概念
> GC(Garbage Collection)：即垃圾回收器，诞生于1960年MIT的Lisp语言，主要是用来回收，释放垃圾占用的空间。

java GC泛指java的垃圾回收机制，该机制是java与C/C++的主要区别之一，我们在日常写java代码的时候，一般都不需要编写内存回收或者垃圾清理的代码，也不需要像C/C++那样做类似delete/free的操作。

## GC 基础要点
要学会看懂gc及定位一些内存泄漏问题。至少要明白:

> 1.哪些内存要回收 ——识别垃圾
> 2.什么时候回收
> 3.怎么回收

 ### 1. 哪些内存要回收
java内存模型中分为五大区域:
我们知道`程序计数器`、`虚拟机栈`、`本地方法栈`，由线程而生，随线程而灭，其中栈中的栈帧随着方法的进入顺序的执行的入栈和出栈的操作，一个栈帧需要分配多少内存取决于具体的虚拟机实现并且在编译期间即确定下来【忽略JIT编译器做的优化，基本当成编译期间可知】，当方法或线程执行完毕后，内存就随着回收，因此无需关心。

而`Java堆`、`方法区`(see: [Metaspace元空间Gc](http://javakk.com/378.html))则不一样。方法区存放着类加载信息，但是一个接口中多个实现类需要的内存可能不太一样，一个方法中多个分支需要的内存也可能不一样【只有在运行期间才可知道这个方法创建了哪些对象没需要多少内存】，这部分内存的分配和回收都是动态的，gc关注的也正是这部分的内存。


- 堆的回收区域
	```css
	为了高效的回收，jvm将堆分为三个区域
	1.新生代（Young Generation）NewSize和MaxNewSize分别可以控制年轻代的初始大小和最大的大小
	2.老年代（Old Generation）
	3.永久代（Permanent Generation）【1.8以后采用元空间，就不在堆中了】
	```
		

 ### 2. 什么时候回收
 
何时触发回收？ 垃圾回收器的不同会有不同。总的来说通常是回收器所负责的区域内存达到或超过某个阈值。或者主动触发，并行的垃圾回收器应该是较为特殊。

现在的jvm常使用`分代收集算法`，对于不同的代有不同的触发条件，虽然 *不同的收集器，* 回收的触发可能稍有不同，但大体上可以满足：

**垃圾回收类型分类**
-   Partial GC：并不收集整个GC堆的模式
	-   Young GC：只收集young gen的GC
	-   Old GC：只收集old gen的GC。只有[CMS](#)的concurrent collection是这个模式
	-   Mixed GC：收集整个young gen以及部分old gen的GC。只有[G1]()有这个模式
-   Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。
Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。

[Major GC和Full GC的区别与触发条件](https://www.zhihu.com/question/41922036/answer/93079526)

最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件：
```
minor GC(young GC):
当年轻代中eden区分配满的时候触发[值得一提的是因为young GC后部分存活的对象会已到老年代(比如对象熬过15轮)，所以过后old gen的占用量通常会变高]

full GC:
①手动调用System.gc()方法 [增加了full GC频率，不建议使用而是让jvm自己管理内存，可以设置-XX:+ DisableExplicitGC来禁止RMI调用System.gc]
②发现perm gen（如果存在永久代的话)需分配空间但已经没有足够空间
③老年代空间不足，比如说新生代的大对象大数组晋升到老年代就可能导致老年代空间不足。
④CMS GC时出现Promotion Faield[pf]
⑤统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间。
这个比较难理解，这是HotSpot为了避免由于新生代晋升到老年代导致老年代空间不足而触发的FUll GC。
比如程序第一次触发Minor GC后，有5m的对象晋升到老年代，姑且现在平均算5m，那么下次Minor GC发生时，先判断现在老年代剩余空间大小是否超过5m，如果小于5m，则HotSpot则会触发full GC(这点挺智能的)
```
	
>HotSpot VM里其它非并发GC的触发条件复杂一些，不过大致的原理与上面说的其实一样。 当然也总有例外。Parallel Scavenge（-XX:+UseParallelGC）框架下，默认是在要触发full GC前先执行一次young GC，并且两次GC之间能让应用程序稍微运行一小下，以期降低full GC的暂停时间（因为young GC会尽量清理了young gen的死对象，减少了full GC的工作量）。


	
 ### 3.  怎么回收

触发堆GC后：
1. 判断对象是否存活 —— 标记
2. 回收已死对象—— 处理

#### 判断对象是否存活的方法

```
1.引用计数算法
早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。
优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。
缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。

2.可达性分析算法
目前主流的商用语言[如java、c#]采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。
它的基本思路是通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。
```
![[可达性分析示意.png]]

#### 可作为GC Roots的对象有四种


```java
①虚拟机栈(栈桢中的本地变量表)中的引用的对象。
②本地方法栈中JNI（native方法)引用的对象
③方法区中的常量引用的对象。【 static final 】
④方法区中的类静态属性引用的对象，一般指被static修饰引用的对象，加载类的时候就加载到内存中。【 static 】
⑤ clazz
```

即使可达性算法中不可达的对象，也不是一定要马上被回收，还有可能被抢救一下。网上例子很多，基本上和深入理解JVM一书讲的一样[对象的生存还是死亡](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Flwang_IT%2Farticle%2Fdetails%2F78650168)

```css
要真正宣告对象死亡需经过两个过程。
1.可达性分析后没有发现引用链
2.查看对象是否有finalize方法，如果有重写且在方法内完成自救[比如再建立引用]，还是可以抢救一下，注意这边一个类的finalize只执行一次，这就会出现一样的代码第一次自救成功第二次失败的情况。[如果类重写finalize且还没调用过，会将这个对象放到一个叫做F-Queue的序列里，这边finalize不承诺一定会执行，这么做是因为如果里面死循环的话可能会时F-Queue队列处于等待，严重会导致内存崩溃，这是我们不希望看到的。]
```

[HotSpot虚拟机如何实现可达性算法](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fonlinemf%2Fp%2F7044953.html)

#### 三大垃圾收集算法 【需要二次整理】

```java
1.标记/清除算法【最基础】
2.复制算法
3.标记/整理算法
jvm采用`分代收集算法`对不同区域采用不同的回收算法。
```

 **效率**：复制算法 > 标记/整理算法 (不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法)> 标记/清除算法（标记/清除算法有内存碎片问题，给大对象分配内存时可能会触发新一轮垃圾回收）

 **内存整齐率**：复制算法 = 标记/整理算法 > 标记/清除算法

 **内存利用率**：标记/整理算法 = 标记/清除算法 > 复制算法

[参考GC算法深度解析](https://www.cnblogs.com/fangfuhai/p/7203468.html?utm_source=itdadao&utm_medium=referral)

> 为什么java虚拟机要采用分代收集算法？
> 根据经验，有假说:
> 1）绝大多数对象都是朝生夕灭的。 [弱分代假说 (Weak Generational Hypothesis)]
> 2）熬过越多次垃圾收集过程的对象就越难以消 亡。[强分代假说 (Strong Generational Hypothesis)]

∴ 收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区 域之中存储。

年轻对象 -> 多是朝生夕灭 -> 复制算法
长寿对象 -> 越难以消亡 -> 标记/整理算法
存放长寿对象的区域回收频率可以较低。以同时兼顾垃圾收集的时间开销和内存的空间有 效利用。

**新生代采用`复制算法`**

新生代中因为对象都是"朝生夕死的"，【深入理解JVM虚拟机上说98%的对象,不知道是不是这么多，总之就是存活率很低】，适用于复制算法【复制算法比较适合用于存活率低的内存区域】。它优化了标记/清除算法的效率和内存碎片问题，且JVM不以5:5分配内存【由于存活率低，不需要复制保留那么大的区域造成空间上的浪费，因此不需要按1:1【原有区域:保留空间】划分内存区域，而是将内存分为一块Eden空间和From Survivor、To Survivor【保留空间】，三者默认比例为8:1:1，优先使用Eden区，若Eden区满，则将对象复制到第二块内存区上。但是不能保证每次回收都只有不多于10%的对象存货，所以Survivor区不够的话，则会依赖老年代年存进行分配】。

GC开始时，对象只会存于Eden和From Survivor区域，To Survivor【保留空间】为空。

GC进行时，Eden区所有存活的对象都被复制到To Survivor区，而From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阈值(默认15是因为对象头中年龄战4bit，新生代每熬过一次垃圾回收，年龄+1)，则移到老年代，没有达到则复制到To Survivor。

**老年代采用`标记/整理算法`或`标记/清除算法`**

由于老年代存活率高，没有额外空间给他做担保，必须使用这两种算法。

标记/整理算法的标记过程任然与标记/清除算法一样，但后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象都向一端移动(冒泡？)，然后直接清理掉端边线以外的内存。

回收前：
![[GC-标记整理算法-回收前.jpg]]
回收后：
![[GC-标记整理算法-回收后.jpg]]

## 垃圾收集器简介

```css
年轻代收集器
Serial、ParNew、Parallel Scavenge
老年代收集器
Serial Old、Parallel Old、CMS收集器
特殊收集器
G1收集器[新型，不在年轻、老年代范畴内]
```

| 名称                        | 线程 | 算法      | stop the world | 特点                                 | 备注                   |
| --------------------------- | ---- | --------- | -------------- | ------------------------------------ | ---------------------- |
| Serial                      | 单   | 复制      | T              | 关注停顿时间                         |                        |
| Serial Old                  | 单   | 标记-整理 | T              | 关注停顿时间                         |                        |
| ParNew                      | 多   | 复制      | T              | 关注停顿时间                         |                        |
| Parallel Scavenge           | 多   | 复制      | T              | 吞吐量优先*                          | 适合后台运算           |
| Parallel Old                | 多   | 标记-整理 | T              | 吞吐量优先                           |                        |
| CMS (Concurrent Mark Sweep) | 多   | 标记-清除 | T              | 获取最短回收停顿时间为目标           | 适合关注响应速度的服务 |
| G1                          | 多   | 混合使用  | T  (10ms)         | 延迟可控的情况下获得尽可能高的吞吐量 | 局部收集               |
| C4                          |      |           |                |                                      |                        |
| ZGC                          |      |           |T (1ms)            |                                      |  不分代             |

*【吞吐量 = 代码运行时间 / (代码运行时间 + 垃圾收集时间) 如果代码运行100min垃圾收集1min，则为99%】

*局部收集 以回收集（Collection Set，一般简称CSet）为单元

CMS收集器
1. 初始标记（CMS initial mark）[Stop The World]
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）  [Stop The World]
4. 并发清除（CMS concurrent sweep）

G1收集器
逻辑分代 物理不分代
1. 初始标记（Initial Marking）[Stop The World]：
	仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。 
2. 并发标记（Concurrent Marking）：
	从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。 
3. 最终标记（Final Marking）[Stop The World]：
	对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。 
4. 筛选回收（Live Data Counting and Evacuation）[Stop The World]：
	负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。
	
	[什么是G1垃圾回收算法](https://blog.csdn.net/bjweimengshu/article/details/79479329)
	
	
	![[10种 垃圾回收器.png]]
	
	Epsilon : 空的GC 什么都不干 用于调试JDK
	Serial 年轻代 串行回收 <- 对应 -> SerialOld 老年代
    PS 年轻代 并行回收      <- 对应 -> ParallelOld 老年代
    ParNew 年轻代 可配合CMS的 PS 并行回收 与PS原理一致
	>Concurrent Mark Sweep 当老年代碎片化之后 会使用 SerialOld 整理老年代！！！！
	
	![[Hotapot对象创建与回收流程(包含栈上分配&逃逸分析).png]]