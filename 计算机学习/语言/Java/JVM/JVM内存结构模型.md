#面试 #JVM #JVM_内存结构

原文 [# 深入理解JVM-内存模型（jmm）和GC](https://www.jianshu.com/p/76959115d486)

相关： [[GC 垃圾回收机制]]

![[JVM内存模型.png]]
```undefined
其中方法区和堆是所有线程共享的，栈，本地方法栈和程序计数器则为线程私有的。
```



### 虚拟机内存结构
#### 五大区域
- 线程共享
	- 程序计数器
		为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器
	- 堆
		**堆是java虚拟机管理内存最大的一块内存区域**，因为堆是所有线程共享的，它的目的是存放对象实例，所以多线程的时候也需要同步机制。也是GC所管理的主要区域。
		```
		java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着
		JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。
		```
		
		根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。
		
		[[JIT编译器 (Just In Time Compiler)]]
		[参考逃逸分析](https://www.jianshu.com/p/20bd2e9b1f03)
		
		**堆的细分**

		
		由于现在的jvm常使用`分代收集算法`，Java堆中还可以被划分为新生代和老年代，新生代再细致点还有Eden(伊甸园)空间，From Survivor，To Survivor【保留空间,回收开始时为空】 (8:1:1)。
		
		1.7之前的Hotspot虚拟机,堆上还有永久代，用以实现方法区。
		
		堆的细分参看分代回收算法：[[GC 垃圾回收机制]]

- 线程私有
	- 方法区
		用于存储已被虚拟机加载的类信息、静态变量、常量，如static修饰的变量加载类的时候就被加载到方法区中。为了区分堆，又被称为非堆（Non-Heap）
		在1.7之前在(JDK1.2 ~ JDK6)的实现中，HotSpot 使用永久代(堆上)实现方法区。
		
		JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace，中文名叫元空间。
		
		[探秘 Metaspace](https://www.sczyh30.com/posts/Java/jvm-metaspace/)
		
		*永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义*
		```
		运行时常量池

		是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。
		```
		
		方法区存储以下信息(since 1.6):
		-   Klass 元数据信息
		-   每个类的运行时常量池（字段、方法、类、接口等符号引用）、编译后的代码
		     `[1.8 存到元空间 metaspace]` --？1.8整个方法区都在元空间了吧
		-   静态字段（无论是否有final）在 instanceKlass 末尾（位于 PermGen 内）
		    `[1.7 从 instanceKlass 末尾移动到 oop 末尾]`
		-   oop（Ordinary Object Pointer（普通对象指针）） 其实就是 Class 对象实例 
		    `[1.7  移到 Java Heap]`
		-   全局字符串常量池 StringTable，本质上就是个 Hashtable 
		    `[1.7 移到 移到 Java Heap]`
		-   符号引用（类型指针是 SymbolKlass）
		    `[1.7 移到 Native Heap 中]`

		![[元空间替换永久代示意图.jpg]]
		
		参考： [# JVM 系列 - 内存区域 - 方法区（六）](	https://www.jianshu.com/p/59f98076b382)
	
		
	- 虚拟机(JVM)栈
		描述的是Java方法执行的内存模型。
		每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
		**平时说的栈一般指局部变量表部分。**
		[[JAVA虚拟机栈帧结构]]
		![[栈帧示意.png]]
	- 本地方法栈
		本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法