同：加锁方式同步，而且都是阻塞式的同步
#锁
see [# Synchronized与ReentrantLock区别总结](https://blog.csdn.net/zxd8080666/article/details/83214089)

### 比较：
- 功能：Synchronized是关键字，不需手动释放; ReentrantLock是JDK 1.5之后提供的API层面的互斥锁，需要手动lock unlock,但灵活性更高
- 性能：从Synchronized引入了偏向锁，轻量级锁 后差不多(重量级锁需要操作系统需要在用户态与内核态之间来回切换，开销大)

- ReentrantLock类提供了一些高级功能：
  1. 等待可中断 持 有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。
  2. 公平锁  必须按照申请锁的时间顺序获得锁
  3. 锁绑定多个条件(等待队列)  用来实现分组唤醒需要唤醒的线程们 例如 生产者消费者模式，生产满了要停止生产(并通知唤醒唤醒消费者)，消费空了要停止消费的场景(并通知唤醒唤醒生产者)。



### ReenTrantLock:
> **ReenTrantLock的实现是一种自旋锁,循环调用CAS操作来实现加锁**。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。